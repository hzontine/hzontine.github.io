---
layout: post
title: Python-Flask
---


Currently, I am enrolled in CPSC 350, Applications of Databases. While the focus of the class is databases, we are also tasked with applying it to a web application. It requires a relatively simple combination of Python on the back-end and Flask on the front-end. For example, in the code below, the first line creates a server sided call, while the function in the second line will handle the call in Python. The route decorator is required before each function to tell Flask which URL it should be triggered.

{% highlight python %}

@app.route('/', methods=['GET', 'POST'])
def mainIndex():
  # Insert code here

{% endhighlight %}

## Importing
  * Flask: Must be imported before we can create an instance of the Flask Class.
  * Psycopg2: Python library that creates a connection to a PostgreSQL database. Used to handle database connection and all of our queries.

{% highlight python %}

from flask import Flask
import psycopg2
import psycopg2.extras

{% endhighlight %}

## Creating an instance of Flask

Since we wish to create an instance for a single module as opposed to an application, we must give Flask() the parameter, __name__. This is essential because Flask needs to know where to look for your templates, static files, etc.

{% highlight python %}

app = Flask(__name__)
{% endhighlight %}

## Connecting to our PostgreSQL database

Next, we need to make a function that connects to our database.

{% highlight python %}

def connectToDatabase():
 return psycopg2.connect('dbname=session user=hzontine password=password host=localhost')

{% endhighlight %}
 
Inside each function we wish to access the database, the following code must appear:

{% highlight python %}

conn = connectToDB()
cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)

{% endhighlight %}

The parameter of conn.cursor() is not essential; however, it does force our results into a Python Dictionary-like container, which can be helpful.

## Running a Query

#### Good Programming Practice: Always wrap this code in a _Try Catch_ statement!

By using cur.mogrify(), the variable queryVar is assigned a string containing the below select statement with all instances of %s replaced by the respective values in queryTerm. Next queryVar must be computed by calling .execute() with one parameter, queryVar, on our cursor variable, cur. The results variable is assigned the value of all the data computed by the execution of the select statement. If cur.fetchall() is replaced by cur.fetchone(), results would be assigned the value of only the first row of information returned by the execution. By wrapping this code in a try statement, should the cur.execute() fail, an error will be printed in order to aid the debugging process.

{% highlight python %}
queryTerm = ('Harry Potter', 'Action')
queryVar = cur.mogrify("SELECT * FROM movies WHERE name LIKE %s AND genre = %s ORDER BY name;", (queryTerm,))
try:
  cur.execute(queryVar)
  results = cur.fetchall()
except Exception as e:
  print("Select from movies failed: %s" % e)
{% endhighlight %}
